#!/usr/bin/python
# coding: utf-8

# Este programa é um exemplo de implementação direta (sem usar estruturas
# elaboradas) do algoritmo de Dijkstra

# Baseado no algoritmo descrito no livro "Algoritmos: Teoria e Prática"
#   A fila de prioridade é implementado fazendo um busca linear em um
#   no vetor de estimativas de menores distâncias, semelhante a
#   implementação de fila de prioridade do algoritmo de Prim do
#   exercício 23.2-2

def initialize_single_source(g, s):
    n = len(g)
    d = [None] * n
    pai = [None] * n
    for v in range(n): # for each v in g.V
        d[v] = float("+infinity")
        pai[v] = None
    d[s] = 0
    return d, pai

def extract_min(Q, S):
    n = len(Q)
    min = None
    for v in range(n): # for each v in g.V
        if not S[v]:
           if min == None:
               min = v
           elif Q[v] < Q[min]:
               min = v
    return min

def dijkstra(g, s):
    d, pai = initialize_single_source(g, s)
    n = len(g)
    S = [False] * n # atributo do vértice que indica se
                    # ele faz parte da árvore de caminhos mínimos
    Q = d           # a fila de prioridade é o próprio vetor de
                    # estimativas de menor distância
    for i in range(n):
        u = extract_min(Q, S)
        S[u] = True # vértice adicionado a árvore de caminhos mínimos
        for w, v in g[u]: # w é o peso da aresta (u, v)
            if d[v] > d[u] + w:
                d[v] = d[u] + w
                pai[v] = u
                # decrease-key não é necessário
                # a lista Q é uma reverência para a lista d
                # como a lista d foi altera, Q também foi
    return d, pai

def teste():
    # cada elemento da lista de adjacências do vértice u é uma tupla (w, v)
    # onde w é o peso da aresta (u, v)
    # grafo da figura 24.6
    grafo = {
    'Oradea' : [(71, 'Zerind'), (151, 'Sibiu')],
    'Zerind' : [(71, 'Oradea'), (75, 'Arad')],
    'Arad' : [(75, 'Zerind'), (140, 'Sibiu'), (118, 'Timisoara')],
    'Timisoara' : [(118, 'Arad'), (111, 'Lugoj')],
    'Lugoj' : [(111, 'Timisoara'), (70, 'Mehadia')],
    'Mehadia' : [(70, 'Lugoj'), (75, 'Dobreta')],
    'Dobreta' : [(75, 'Mehadia'), (120, 'Craiova')],
    'Sibiu' : [(151, 'Oradea'), 'Arad', 'RimnicuVilcea', 'Fagaras'],
    'Fagaras' : ['Sibiu', 'Bucharest'],
    'RimnicuVilcea' : ['Sibiu', 'Craiova', 'Pitesti'],
    'Craiova' : ['Dobreta', 'RimnicuVilcea', 'Pitesti'],
    'Pitesti' : ['RimnicuVilcea', 'Craiova', 'Bucharest'],
    'Bucharest' : ['Fagaras', 'Pitesti', 'Giurgiu', 'Urziceni'],
    'Giurgiu' : ['Bucharest'],
    'Urziceni' : ['Bucharest', 'Vaslui', 'Hirsova'],
    'Hirsova' : ['Urziceni', 'Eforie'],
    'Eforie' : ['Hirsova'],
    'Vaslui' : ['Urziceni', 'Iasi'],
    'Iasi' : ['Vaslui', 'Neamt'],
    'Neamt' : ['Iasi'],
}

    d, pai = dijkstra(grafo, 1)

    print ("d =", d)
    print ("pai =", pai)

if __name__ == "__main__":
    teste()
